\documentclass[doublespacing,12pt,oneside]{article}
\usepackage[top=2.5cm, left=2.5cm, right=2.5cm, bottom=2.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-nodecimaldot,es-tabla]{babel}
\usepackage{caption, subcaption}
\usepackage{graphicx}
\usepackage{imakeidx}
\usepackage{biblatex}
\usepackage{float}
\addbibresource{bib/protocolo.bib}
\addbibresource{biblio.bib}
\graphicspath{{./figs/}}
\usepackage{setspace}
\begin{document}
\tableofcontents\clearpage

\section{Introducción}

\subsection{Planteamiento del Problema}
El desarrollo de software orientado a objetos requiere la implementación de modelos que no solo representen entidades estáticas, sino que también gestionen interacciones complejas y flujos de estados dinámicos. Para este proyecto, se plantea el desafío de replicar la lógica subyacente de un sistema de batalla por turnos, basado en los videojuegos de Pokémon.

El problema central consiste en diseñar una arquitectura de software capaz de gestionar múltiples variables simultáneas: el cálculo de daño basado en una matriz de tipos elementales (debilidades y resistencias), la administración de turnos basada en estadísticas de velocidad, y la gestión de inventarios y estados alterados del personaje. Es necesario desarrollar una solución modular bajo el patrón Modelo-Vista-Controlador (MVC) que permita desacoplar la lógica del juego de la interfaz de usuario, garantizando un sistema robusto, extensible y mantenible.

\subsection{Motivación}
La simulación de sistemas complejos es una de las aplicaciones prácticas más efectivas para consolidar los conocimientos de programación orientada a objetos y estructuras de datos. Este proyecto surge de la necesidad de aplicar conceptos teóricos vistos en el curso —como polimorfismo, abstracción, herencia y manejo de colecciones— en un escenario práctico y reconocible.

Un simulador de batallas no es trivial; es un escenario ideal para enfrentar problemas comunes en el desarrollo profesional, tales como la implementación de patrones de diseño (como \textit{Strategy} para los ítems) y la optimización de algoritmos de búsqueda (para la tabla de tipos). Además, la motivación se extiende a la creación de una experiencia de usuario interactiva en consola, superando la ejecución lineal de scripts simples para crear una aplicación que responde dinámicamente a las decisiones del usuario.

\subsection{Objetivos}

\textbf{Objetivo General:} \\
Desarrollar una aplicación de consola en lenguaje Dart que simule fielmente un combate Pokémon, implementando una arquitectura Modelo-Vista-Controlador (MVC) para gestionar la lógica de turnos, el cálculo de daño elemental y la interacción con el usuario.

\vspace{0.3cm}
\textbf{Objetivos Específicos:}
\begin{itemize}
    \item \textbf{Implementar una matriz de efectividad de tipos:} Desarrollar una estructura de datos eficiente que permita calcular multiplicadores de daño (x2, x0.5, x0) para los 18 tipos elementales, evitando el uso excesivo de condicionales.
    \item \textbf{Diseñar un sistema de turnos dinámico:} Programar un algoritmo de control de flujo que determine el orden de actuación basándose en la velocidad de las entidades y que se adapte a modificaciones en tiempo real (como estados de parálisis).
    \item \textbf{Desarrollar un modelo flexible y escalable:} Hacer uso de herencia para permitir la instanciación genérica de Pokémon y la gestión de estados alterados (veneno, quemadura, congelamiento).
    \item \textbf{Integrar interactividad y gestión de recursos:} Habilitar un menú interactivo que permita al usuario elegir estratégicamente entre atacar o utilizar objetos del inventario para recuperar salud o curar estados.
\end{itemize}


\section{Marco Teórico (Conceptos):}

Para el desarrollo del simulador de videojuego Pokémon (Proyecto 3), se implementaron herramientas fundamentales de la Programación Orientada a Objetos para aprovechar la modularidad, reutilización de código. A continuación, se detalla la aplicación práctica de cada concepto:

\subsection{Abstracción de Clases}
La abstracción permite representar entidades complejas del mundo real como modelos de software simplificados, centrados en los atributos y comportamientos relevantes para el contexto del sistema \cite{joyanes}.

\textbf{Implementación:}
Se definieron las clases \texttt{Pokemon} y \texttt{Ataque}. La clase \texttt{Pokemon} abstrae las estadísticas vitales como \textit{Hit Points} (HP), Velocidad y Nivel, ocultando complejidad innecesaria. 

\subsection{Herencia }
La herencia es el mecanismo por el cual una clase se deriva de otra, adquiriendo sus atributos y métodos, lo que permite la reutilización de código y establece una jerarquía de tipos \cite{deitel}.

\textbf{Implementación:}
Para satisfacer el requerimiento de "ítems de curación", se diseñó una jerarquía de herencia donde la clase abstracta \texttt{Item} sirve como clase base. De ella derivan las clases concretas \texttt{Pocion} y \texttt{CuraTotal}. Esto permitió compartir el atributo \texttt{nombre} y obligar a la implementación del comportamiento específico en las subclases.

\subsection{Polimorfismo}
El polimorfismo permite que objetos de diferentes clases respondan al mismo mensaje de manera distinta, facilitando la extensibilidad del sistema \cite{joyanes}.

\textbf{Implementación:}
El método abstracto \texttt{usar(Pokemon p, CombateView view)} definido en la clase \texttt{Item} es polimórfico.
\begin{itemize}
    \item En la clase \texttt{Pocion}, el método incrementa la propiedad \texttt{vida}.
    \item En la clase \texttt{CuraTotal}, el método altera la propiedad \texttt{estado} a \texttt{Estado.sano}.
\end{itemize}
El controlador del juego (\texttt{CombateController}) invoca este método sin necesidad de conocer el tipo exacto del objeto, simplificando la lógica del menú "Mochila".

\subsection{Encapsulamiento y Arquitectura MVC}
El encapsulamiento oculta los detalles internos de implementación y protege la integridad de los datos, exponiendo solo una interfaz pública segura \cite{sommerville}.

\textbf{Implementación:}
Se adoptó el patrón de arquitectura Modelo-Vista-Controlador (MVC):
\begin{itemize}
    \item \textbf{Modelo:} Clases de datos como \texttt{Pokemon} y \texttt{TablaTipos}.
    \item \textbf{Vista:} La interfaz \texttt{CombateView} encapsula todas las operaciones de entrada/salida (I/O), separando la lógica de presentación de la lógica de negocio.
    \item \textbf{Controlador:} La clase \texttt{CombateController} gestiona el flujo de la batalla.
\end{itemize}

\subsection{Miembros Estáticos (Static)}
Los miembros estáticos pertenecen a la clase en lugar de a una instancia particular, permitiendo el acceso a utilidades y constantes compartidas \cite{deitel}.

\textbf{Implementación:}
La clase \texttt{TablaTipos} utiliza un mapa estático (\texttt{efectividad}) y un método estático (\texttt{obtenerMultiplicador}) para calcular las debilidades y resistencias (x2.0, x0.5, x0.0). Esto permite consultar la tabla de tipos globalmente sin instanciar objetos, optimizando el uso de memoria según la Figura 1 del planteamiento.

\clearpage
\section{Desarrollo}
\subsection{Desarrollo en Serie de Pasos}
\subsubsection*{1. \textbf{Definición de Tipos y Efectividad}}
Se creó una estructura de datos estática ($\texttt{TablaTipos}$) para implementar la \textbf{matriz completa de efectividad} entre todos los tipos. Esto permite al sistema consultar dinámicamente el multiplicador de daño (ej., $0.5$, $1.0$, $2.0$) para cualquier combinación de tipo de ataque y tipo de defensor.

\subsubsection*{2. \textbf{Expansión del Modelo Ataque}}
La clase $\texttt{Ataque}$ fue implementada para incluir una \textbf{potencia} base y un campo opcional ($\texttt{efectoEstado}$) que define el problema de estado que puede aplicar (ej., Quemado o Paralizado) con cierta probabilidad.

\subsubsection*{3. \textbf{Implementación de Estados Alterados}}
Se definió una enumeración ($\texttt{Estado}$) para categorizar los problemas de estado. Se implementó la función $\texttt{aplicarEfectoDeEstado()}$ en la clase $\texttt{Pokemon}$ para calcular y restar el \textbf{daño pasivo por estado} (proporcional a la vida máxima) al final de cada turno.

\subsubsection*{4. \textbf{Desarrollo del Sistema de Items}}
Se implementó la clase abstracta $\texttt{Item}$ con su método $\texttt{usar()}$. Se crearon clases concretas ($\texttt{Poción}$, $\texttt{MaxPoción}$, $\texttt{CuraTotal}$) que extienden $\texttt{Item}$ e implementan la lógica específica para restaurar vida o eliminar estados.

\subsubsection*{5. \textbf{Estructura de la Aplicación y Temas}}
Se definió la estructura básica de Flutter ($\texttt{MaterialApp}$) y se configuró el tema con colores oscuros y esquemas de color específicos para la aplicación.

\subsubsection*{6. \textbf{Gestión de Fases del Combate}}
Se implementó la enumeración $\texttt{FaseTurno}$ para controlar el estado de la interfaz de usuario: $\texttt{menuPrincipal}$, $\texttt{seleccionAtaque}$, $\texttt{seleccionMochila}$, $\texttt{animacion}$, $\texttt{finJuego}$.

\subsubsection*{7. \textbf{Renderizado del Campo de Batalla y Sprites}}
Se utilizó un $\texttt{Stack}$ de *widgets* para posicionar los elementos en capas: el fondo degradado y los *widgets* de imagen que cargan los \textbf{sprites animados} del Pokémon (jugador en la parte trasera, rival en el frente) utilizando las URL dinámicas basadas en su ID. 

\subsubsection*{8. \textbf{Implementación del HUD}}
Se creó un *widget* modular ($\texttt{\_buildPokemonHUD}$) que renderiza el nombre, nivel, el indicador de \textbf{estado alterado} y, crucialmente, la \textbf{barra de vida} con su color dinámico (verde, naranja, rojo).

\subsubsection*{9. \textbf{Panel de Logs y Control}}
Se implementó un área de texto con $\texttt{ListView.builder}$ para mostrar los mensajes de combate. Se añadió la lógica de *auto-scroll* para que el $\texttt{log}$ siempre muestre el último mensaje. Se implementaron los botones interactivos para cada fase.

\subsubsection*{10. \textbf{Lógica de Turno Asíncrono}}
Todas las funciones clave del combate ($\texttt{ejecutarAtaqueJugador}$, $\texttt{turnoRival}$) se definieron como \textbf{asíncronas} ($\texttt{async/await}$). Esto permite la introducción de pausas ($\texttt{Future.delayed}$) para simular el tiempo que toma una acción antes de continuar.

\subsubsection*{11. \textbf{Determinación de Prioridad}}
Se implementó la lógica de quién ataca primero, comparando la $\texttt{velocidad}$ de los Pokémon. Se incluyó la verificación de la \textbf{parálisis}, que introduce una probabilidad de que el Pokémon paralizado pierda su turno, afectando la prioridad.

\subsubsection*{12. \textbf{Cálculo de Daño Avanzado}}
El método $\texttt{procesarAtaque}$ calcula el daño final aplicando: la \textbf{Potencia} del ataque, el \textbf{Multiplicador de Efectividad}, el \textbf{Bonus STAB} ($\times 1.5$) si el ataque es del mismo tipo, y un \textbf{Factor de Variación Aleatoria} ($0.85 \text{ a } 1.00$).

\subsubsection*{13. \textbf{Transiciones de Fase y Fin de Turno}}
Se implementó el cambio de estado ($\texttt{setState}$) al inicio y final de cada acción. La función $\texttt{finalizarTurno}$ verifica el daño por estado pasivo y comprueba si la vida de algún Pokémon ha llegado a cero (pasando a $\texttt{finJuego}$) o si ambos siguen en pie, regresando a la fase $\texttt{menuPrincipal}$.

\subsection{Conceptos en la Aplicación}

\textbf{Encapsulación:}  
En el programa, la encapsulación se refleja en la manera en que cada componente administra su propia lógica interna sin exponer detalles innecesarios. La función \texttt{main} únicamente define el flujo general, mientras que el manejo del tiempo de espera y la ejecución diferida se encuentra dentro de \texttt{Future.delayed}. Esta separación permite mantener un control adecuado sobre las partes del programa y favorece la organización del código, evitando dependencias excesivas entre módulos.

\textbf{Abstracción:}  
La abstracción se aplica mediante el uso de estructuras como \texttt{Future} y \texttt{Duration}, las cuales ocultan la complejidad del manejo del \textit{Event Loop}. El programador sólo debe especificar qué tarea desea ejecutar y en cuánto tiempo, sin preocuparse por los detalles internos del procesamiento asíncrono. Esto permite trabajar con procesos complejos mediante interfaces simples y comprensibles.

\textbf{Composición:}  
El programa implementa composición al integrar objetos de apoyo dentro del flujo principal sin necesidad de recurrir a herencia. Componentes como \texttt{Duration(seconds: 2)} y \texttt{Future.delayed} se utilizan directamente como partes funcionales del programa. Esta técnica favorece la reutilización de componentes ya existentes y permite construir comportamientos más completos sin duplicar código.

\textbf{Polimorfismo:}  
El polimorfismo aparece cuando se pasa una función callback dentro de \texttt{Future.delayed}. Este callback puede representar distintos comportamientos, lo que permite que la misma estructura ejecute acciones diferentes según la función proporcionada. Gracias a esto, el diseño se vuelve flexible y adaptable sin modificar la estructura principal.

\textbf{Responsabilidad Única:}  
Cada elemento del programa cumple una única responsabilidad. La función \texttt{main} se encarga del flujo general, \texttt{Future.delayed} administra la tarea programada y el \textit{Event Loop} controla la ejecución en segundo plano. Esta distribución clara evita que un módulo realice tareas adicionales y facilita la lectura y mantenimiento del código.

\textbf{Arquitectura MVC:}  
Aunque el programa es corto, en su estructura puede identificarse una organización compatible con el patrón \textit{Modelo–Vista–Controlador} (MVC). La función \texttt{main} actúa como el \textit{Controlador}, ya que coordina el flujo del programa e indica cuándo deben ejecutarse las tareas. El manejo del tiempo mediante \texttt{Future} y \texttt{Duration} funciona como el \textit{Modelo}, puesto que encapsula la lógica interna relacionada con los procesos asíncronos. Finalmente, las salidas impresas con \texttt{print} representan la \textit{Vista}, encargada de mostrar la información al usuario. Esta separación implícita de responsabilidades contribuye a un diseño organizado, modular y fácil de extender.


\subsection{Diagramas UML}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{capturas/Diagramaestatico.png}
    \caption{Diagrama estatico de clases.}
\end{figure}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{capturas/Diagrama dinámico de secuencia.png}
    \caption{Diagrama dinamico de secuencia.}
\end{figure}


\section{Resultados relevantes}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Inicio.png}
    \caption{Menú al iniciar la aplicación (Status de batalla inicial)}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Menu-Ataque.png}
    \caption{Menú de selección de ataque}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Status-Ataque.png}
    \caption{Status de la batalla después de realizar un movimiento (ataque)}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Status-Contraataque.png}
    \caption{Status del contra-ataque del enemigo}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Menú-Mochila.png}
    \caption{Menú de selección de objetos en mochila}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Status-UsoPocion.png}
    \caption{Status de batalla después de usar poción}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Status-Efecto.png}
    \caption{Status de efecto sobre nuestro pókemon (Congelamiento)}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{Resultados/Status-Victoria.png}
    \caption{Pókemon rival derrotado}
\end{figure}

\section{Conclusiones}
 
El desarrollo de este código permitió consolidar los conocimientos fundamentales de la programación orientada a objetos, aplicando principios como la encapsulación, la abstracción, la composición y el polimorfismo dentro de un ejemplo práctico y funcional. Asimismo, el análisis de su estructura facilitó la comprensión de cómo estos conceptos se integran naturalmente en el manejo de tareas asíncronas en Dart. De igual manera, el estudio del programa posibilitó relacionarlo con los fundamentos del modelado mediante diagramas UML, ya que fue posible identificar responsabilidades, flujos de interacción y la separación implícita en capas compatible con la arquitectura MVC. En conjunto, este ejercicio no sólo reforzó aspectos teóricos de la POO y de los modelos de diseño, sino que también permitió comprender de forma más profunda el comportamiento interno del código, su organización y los principios que lo hacen claro, modular y escalable.


\clearpage

\printbibliography

\end{document}
